package de.wackernagel.android.sidekick.annotations.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.lang.model.element.Modifier;
import javax.tools.Diagnostic;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;

public class ContractGenerator {

    private final TypeSpec generatedContract;

    public ContractGenerator(final String className, final Set<ColumnField> fields, final String authority) {
        final TypeSpec.Builder classBuilder = TypeSpec.classBuilder(className + "Contract")
                .addModifiers(PUBLIC)
                .addJavadoc("Generated by Sidekick at " + new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.ENGLISH).format(new Date()) + "\n");

        String table = className.toLowerCase();
        if ( !table.endsWith("s"))
            table = table.concat( "s" );
        else if( table.endsWith( "s" ) )
            table = table.concat( "es" );
        else if( table.endsWith( "y" ) )
            table = table.substring( 0, table.length() - 1 ).concat( "ies" );

        extend( classBuilder, table, fields );
        tableConstant(classBuilder, table);
        columnConstants(classBuilder, fields);
        projection(classBuilder, fields);
        contentUri(classBuilder, authority);
        insert(classBuilder, fields);
        update(classBuilder);
        delete(classBuilder);

        generatedContract = classBuilder.build();
    }

    private void extend( final TypeSpec.Builder classBuilder, final String table, final Set<ColumnField> fields) {
        classBuilder.superclass(ClassName.get("de.wackernagel.android.sidekick.frameworks.contentproviderprocessor.contract", "TableContract"));

        classBuilder.addMethod(
                MethodSpec.methodBuilder("getTable")
                        .addModifiers(PUBLIC)
                        .addAnnotation(Override.class)
                        .returns(String.class)
                        .addStatement("return $L", "TABLE")
                        .build());

        final ClassName db = ClassName.get("android.database.sqlite", "SQLiteDatabase");

        classBuilder.addMethod(
                MethodSpec.methodBuilder("onCreate")
                        .addModifiers(PUBLIC)
                        .addAnnotation(Override.class)
                        .addParameter(db, "db", FINAL)
                        .addStatement("db.execSQL($S)", createTableStatement( table, fields))
                        .returns(TypeName.VOID)
                        .build()
        );

        classBuilder.addMethod(
                MethodSpec.methodBuilder("onUpgrade")
                        .addModifiers(PUBLIC)
                        .addAnnotation(Override.class)
                        .addParameter(db, "db", FINAL)
                        .addParameter(int.class, "oldVersion", FINAL)
                        .addParameter(int.class, "newVersion", FINAL)
                        .returns(TypeName.VOID)
                        .build()
        );
    }

    private String createTableStatement( final String table, final Set<ColumnField> fields) {
        final StringBuilder sql = new StringBuilder();
        sql.append( "CREATE TABLE IF NOT EXISTS " ).append( table ).append("(");
        int index = 0;
        for( ColumnField column : fields ) {
            sql.append( column.getColumnName() )
                .append( " " )
                .append( column.getSQLiteType() );
            if( column.isPrimaryKey() )
                sql.append( " PRIMARY KEY AUTOINCREMENT");
            if( column.isNotNull() )
                sql.append( " NOT NULL");
            String defaultValue = column.defaultValue();
            if( defaultValue != null && defaultValue.length() > 0 )
                sql.append( " DEFAULT " ).append( defaultValue );
            if( column.isUnique() )
                sql.append( " UNIQUE" );
            if( column.isBoolean() )
                sql.append( " CHECK (" ).append( column.getColumnName() ).append( " IN ( 0, 1 ) )" );
            if( index != fields.size() - 1 )
                sql.append( ", " );
            index++;
        }
        sql.append(");");
        return sql.toString();
    }



    private void tableConstant( final TypeSpec.Builder classBuilder, final String name) {
        classBuilder.addField(constant(String.class, "TABLE", name).addJavadoc("SQLite table name\n").build());
    }

    private void insert( final TypeSpec.Builder classBuilder, final Set<ColumnField> fields ) {
        ClassName uri = ClassName.get("android.net", "Uri");
        ClassName contentValues = ClassName.get( "android.content", "ContentValues" );
        ClassName context = ClassName.get( "android.content", "Context" );
        ClassName nullable = ClassName.get( "android.support.annotation", "Nullable" );
        ClassName nonNull = ClassName.get( "android.support.annotation", "NonNull" );

        MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder("insert")
                .returns(uri)
                .addModifiers(PUBLIC, STATIC, FINAL)
                .addAnnotation(nullable)
                .addParameter( ParameterSpec.builder(context, "context", FINAL).addAnnotation( nonNull ).build() )
                .addStatement("final $T insert = new $T()", contentValues, contentValues);
        for( ColumnField field : fields ) {
            if( field.getColumnName().equals("_id") )
                continue;
            methodBuilder.addParameter(field.getObjectType(), field.getFieldName(), FINAL);
            if( field.isBoolean() ) {
                methodBuilder.addStatement( "insert.put( $L, $L ? 1 : 0 )", field.getConstantFieldName(), field.getFieldName() );
            } else {
                methodBuilder.addStatement( "insert.put( $L, $L )", field.getConstantFieldName(), field.getFieldName() );
            }
        }
        methodBuilder.addStatement("return context.getContentResolver().insert( CONTENT_URI, insert )");

        classBuilder.addMethod(
                methodBuilder.build());
    }

    private void update( final TypeSpec.Builder classBuilder ) {
        ClassName contentValues = ClassName.get( "android.content", "ContentValues" );
        ClassName context = ClassName.get( "android.content", "Context" );
        ClassName nullable = ClassName.get( "android.support.annotation", "Nullable" );
        ClassName nonNull = ClassName.get( "android.support.annotation", "NonNull" );

        classBuilder.addMethod(
                MethodSpec.methodBuilder("update")
                        .returns(int.class)
                        .addModifiers(PUBLIC, STATIC, FINAL)
                        .addParameter(ParameterSpec.builder(context, "context", FINAL).addAnnotation(nonNull).build())
                        .addParameter(ParameterSpec.builder(contentValues, "update", FINAL).addAnnotation(nullable).build())
                        .addParameter(ParameterSpec.builder(String.class, "where", FINAL).addAnnotation(nullable).build())
                        .addParameter(ParameterSpec.builder(String[].class, "selectionArgs", FINAL).addAnnotation(nullable).build())
                        .addStatement("return context.getContentResolver().update( CONTENT_URI, update, where, selectionArgs )")
                        .build() );
    }

    private void delete( final TypeSpec.Builder classBuilder ) {
        ClassName context = ClassName.get( "android.content", "Context" );
        ClassName nullable = ClassName.get( "android.support.annotation", "Nullable" );
        ClassName nonNull = ClassName.get( "android.support.annotation", "NonNull" );

        classBuilder.addMethod(
                MethodSpec.methodBuilder("delete")
                        .returns(int.class)
                        .addModifiers(PUBLIC, STATIC, FINAL)
                        .addParameter(ParameterSpec.builder(context, "context", FINAL).addAnnotation(nonNull).build())
                        .addParameter(ParameterSpec.builder(String.class, "where", FINAL).addAnnotation(nullable).build())
                        .addParameter(ParameterSpec.builder(String[].class, "selectionArgs", FINAL).addAnnotation(nullable).build())
                        .addStatement("return context.getContentResolver().delete( CONTENT_URI, where, selectionArgs )")
                        .build() );
    }

    private static void columnConstants( final TypeSpec.Builder classBuilder, final Set<ColumnField> columnFields ) {
        boolean first = true;
        for( ColumnField columnField : columnFields ) {
            final FieldSpec.Builder field = constant(String.class, columnField.getConstantFieldName(), columnField.getColumnName());
            if( first ) {
                field.addJavadoc( "SQLite column names\n" );
                first = false;
            }
            classBuilder.addField( field.build() );
        }
    }

    private static void projection( final TypeSpec.Builder classBuilder, final Set<ColumnField> columns ) {
        if( columns.size() > 0 ) {
            final StringBuilder pattern = new StringBuilder();
            final Set<String> values = new LinkedHashSet<>(columns.size());
            for( ColumnField column : columns ) {
                if( pattern.length() > 0 ) {
                    pattern.append(", ");
                }
                pattern.append("$L");
                values.add(column.getConstantFieldName());
            }

            classBuilder.addField(
                    FieldSpec.builder( String[].class, "PROJECTION" )
                            .addModifiers(PUBLIC, STATIC, FINAL)
                            .initializer("{ " + pattern.toString() + " }", values.toArray())
                            .addJavadoc("ContentProvider helper\n")
                            .build());
        }
    }

    private static void contentUri(final TypeSpec.Builder classBuilder, final String authority) {
        if (authority != null && authority.length() > 0) {
            ClassName uri = ClassName.get( "android.net", "Uri");
            classBuilder.addField(
                    FieldSpec.builder(uri, "CONTENT_URI")
                            .addModifiers(PUBLIC, STATIC, FINAL)
                            .initializer("Uri.parse( \"content://" + authority + "/\" + $L )", "TABLE")
                            .build());
        }
    }

    private static FieldSpec.Builder constant(final Class<?> type, final String name, final String value) {
        return constant(type, name, "$S", value);
    }

    private static FieldSpec.Builder constant(final Class<?> type, final String name, final String pattern, final String value) {
        return FieldSpec.builder(type, name)
                .addModifiers(PUBLIC, STATIC, FINAL)
                .initializer(pattern, value);
    }

    public void writeClass( final String packageName, final String className, final Messager log, final Filer filer) {
        log.printMessage(Diagnostic.Kind.NOTE, "Generate contract for " + packageName + "." + className);
        try {
            JavaFile javaFile = JavaFile.builder(packageName, generatedContract).build();
            javaFile.writeTo( filer );
        } catch (IOException e) {
            log.printMessage(Diagnostic.Kind.WARNING, "File wasn't generated.");
        }
    }
}
