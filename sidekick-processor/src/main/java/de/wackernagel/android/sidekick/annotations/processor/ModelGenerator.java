package de.wackernagel.android.sidekick.annotations.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;

import static com.squareup.javapoet.TypeSpec.classBuilder;
import static javax.lang.model.element.Modifier.PUBLIC;

public class ModelGenerator {

    private TypeSpec generatedModel;

    private static final ClassName nullable = ClassName.get( "android.support.annotation", "Nullable" );
    private static final ClassName nonNull = ClassName.get( "android.support.annotation", "NonNull" );

    public ModelGenerator(final TableDefinition tableDefinition, final Set<ColumnDefinition> columnDefinitions) {
        final TypeSpec.Builder classBuilder = classBuilder(tableDefinition.getClassName() + "Model")
                .addModifiers(PUBLIC)
                .addJavadoc("Generated by Sidekick at " + new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.ENGLISH).format(new Date()) + "\n");

        memberField( classBuilder, columnDefinitions );
        constructor(classBuilder, columnDefinitions);
        getterAndSetter(classBuilder, columnDefinitions);
        toString(classBuilder, columnDefinitions, tableDefinition.getTableName());

        generatedModel = classBuilder.build();
    }

    private static void toString(final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields, final String className) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("toString")
                .addAnnotation( Override.class )
                .returns( String.class )
                .addModifiers( Modifier.PUBLIC );

        final StringBuilder statement = new StringBuilder();
        final List<String> args = new ArrayList<>();

        statement.append( "return $S +" );
        args.add( className + "(" );

        int index = 0;
        for( ColumnDefinition columnDefinition : fields ) {
            statement.append("\n$S + $L +");
            args.add( (index > 0 ? ", " : "" ) + columnDefinition.getFieldName() + "=" );
            args.add( columnDefinition.getFieldName() );
            index++;
        }
        statement.append( "$S" );
        args.add( ")" );

        method.addStatement( statement.toString(), args.toArray() );
        classBuilder.addMethod(method.build());
    }

    private static void getterAndSetter(final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields) {
        for( ColumnDefinition columnDefinition : fields ) {
            final String name = Character.toTitleCase( columnDefinition.getFieldName().charAt( 0 ) ) + columnDefinition.getFieldName().substring( 1 );

            final String prefix = columnDefinition.isBoolean() ? "is" : "get";
            final MethodSpec.Builder getMethod = MethodSpec.methodBuilder( prefix + name)
                    .addModifiers(Modifier.PUBLIC)
                    .returns(columnDefinition.getObjectType())
                    .addStatement("return $N", columnDefinition.getFieldName());

            if( columnDefinition.isString() || columnDefinition.isForeignKey() ) {
                if( columnDefinition.isNotNull() ) {
                    getMethod.addAnnotation(nonNull);
                } else {
                    getMethod.addAnnotation(nullable);
                }
            }

            classBuilder.addMethod(getMethod.build());

            if( !columnDefinition.isFinal() ) {
                final ParameterSpec.Builder param = ParameterSpec.builder(columnDefinition.getObjectType(), columnDefinition.getFieldName(), Modifier.FINAL);

                if( columnDefinition.isString() || columnDefinition.isForeignKey() ) {
                    if( columnDefinition.isNotNull() ) {
                        param.addAnnotation( nonNull );
                    } else {
                        param.addAnnotation( nullable );
                    }
                }

                final MethodSpec.Builder setMethod = MethodSpec.methodBuilder("set" + name)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(TypeName.VOID)
                        .addParameter( param.build() )
                        .addStatement("this.$N = $N", columnDefinition.getFieldName(), columnDefinition.getFieldName());
                classBuilder.addMethod( setMethod.build() );
            }
        }
    }

    private static void constructor(final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields) {
        final MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
                .addModifiers( Modifier.PUBLIC );
        for( ColumnDefinition columnDefinition : fields ) {
            if( columnDefinition.isCollectionType() ) {
                constructor.addStatement( "this.$N = new $T()", columnDefinition.getFieldName(), columnDefinition.getInstantiableCollectionType() );
                continue;
            }

            final ParameterSpec.Builder parameter = ParameterSpec.builder( columnDefinition.getObjectType(), columnDefinition.getFieldName(), Modifier.FINAL );
            if( columnDefinition.isString() || columnDefinition.isForeignKey() ) {
                if( columnDefinition.isNotNull() ) {
                    parameter.addAnnotation( nonNull );
                } else {
                    parameter.addAnnotation( nullable );
                }
            }

            constructor.addParameter(parameter.build())
                    .addStatement("this.$N = $N", columnDefinition.getFieldName(), columnDefinition.getFieldName());
        }
        classBuilder.addMethod( constructor.build() );
    }

    private static void memberField( final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields) {
        for( ColumnDefinition column : fields ) {
            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(column.getObjectType(), column.getFieldName(), Modifier.PRIVATE);
            if( column.isFinal() ) {
                fieldBuilder.addModifiers(Modifier.FINAL);
            }
            classBuilder.addField(fieldBuilder.build());
        }
    }

    public boolean writeClass( final String packageName, final Filer filer) {
        try {
            final JavaFile javaFile = JavaFile.builder(packageName, generatedModel).build();
            javaFile.writeTo( filer );
        } catch (IOException e) {
            return false;
        }
        return true;
    }
}
