package de.wackernagel.android.sidekick.annotations.processor;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.Filer;
import javax.annotation.processing.Messager;
import javax.lang.model.element.Modifier;
import javax.tools.Diagnostic;

import static com.squareup.javapoet.TypeSpec.classBuilder;
import static javax.lang.model.element.Modifier.PUBLIC;

public class ModelGenerator {

    private TypeSpec generatedModel;

    private static final ClassName nullable = ClassName.get( "android.support.annotation", "Nullable" );
    private static final ClassName nonNull = ClassName.get( "android.support.annotation", "NonNull" );

    public ModelGenerator(final String className, final Set<ColumnField> fields) {
        final TypeSpec.Builder classBuilder = classBuilder(className + "Model")
                .addModifiers(PUBLIC)
                .addJavadoc("Generated by Sidekick at " + new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.ENGLISH).format(new Date()) + "\n");

        memberField( classBuilder, fields );
        constructor(classBuilder, fields);
        getterAndSetter(classBuilder, fields);
        toString(classBuilder, fields, className);

        generatedModel = classBuilder.build();
    }

    private static void toString(final TypeSpec.Builder classBuilder, final Set<ColumnField> fields, final String className) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("toString")
                .addAnnotation( Override.class )
                .returns( String.class )
                .addModifiers( Modifier.PUBLIC );

        final StringBuilder statement = new StringBuilder();
        final List<String> args = new ArrayList<>();

        statement.append( "return $S +" );
        args.add( className + "(" );

        int index = 0;
        for( ColumnField columnField : fields ) {
            statement.append("\n$S + $L +");
            args.add( (index > 0 ? ", " : "" ) + columnField.getFieldName() + "=" );
            args.add( columnField.getFieldName() );
            index++;
        }
        statement.append( "$S" );
        args.add( ")" );

        method.addStatement( statement.toString(), args.toArray() );
        classBuilder.addMethod(method.build());
    }

    private static void getterAndSetter(final TypeSpec.Builder classBuilder, final Set<ColumnField> fields) {
        for( ColumnField columnField : fields ) {
            final String name = Character.toTitleCase( columnField.getFieldName().charAt( 0 ) ) + columnField.getFieldName().substring( 1 );

            final MethodSpec.Builder getMethod = MethodSpec.methodBuilder("get" + name)
                    .addModifiers(Modifier.PUBLIC)
                    .returns(columnField.getObjectType())
                    .addStatement("return $N", columnField.getFieldName());
            if( columnField.isString() && columnField.isNotNull() )
                getMethod.addAnnotation(nonNull);
            classBuilder.addMethod( getMethod.build());

            if( !columnField.isFinal() ) {
                final ParameterSpec.Builder param = ParameterSpec.builder(columnField.getObjectType(), columnField.getFieldName(), Modifier.FINAL);

                if( columnField.isString() && columnField.isNotNull() )
                    param.addAnnotation( nonNull );

                final MethodSpec.Builder setMethod = MethodSpec.methodBuilder("set" + name)
                        .addModifiers(Modifier.PUBLIC)
                        .returns(TypeName.VOID)
                        .addParameter( param.build() )
                        .addStatement("this.$N = $N", columnField.getFieldName(), columnField.getFieldName());
                classBuilder.addMethod( setMethod.build() );
            }
        }
    }

    private static void constructor(final TypeSpec.Builder classBuilder, final Set<ColumnField> fields) {
        final MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
                .addModifiers( Modifier.PUBLIC );
        for( ColumnField columnField : fields ) {
            constructor.addParameter(columnField.getObjectType(), columnField.getFieldName(), Modifier.FINAL )
                    .addStatement("this.$N = $N", columnField.getFieldName(), columnField.getFieldName());
        }
        classBuilder.addMethod( constructor.build() );
    }

    private static void memberField( final TypeSpec.Builder classBuilder, final Set<ColumnField> fields) {
        for( ColumnField column : fields ) {
            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(column.getObjectType(), column.getFieldName(), Modifier.PRIVATE);
            if( column.isFinal() ) {
                fieldBuilder.addModifiers(Modifier.FINAL);
            }
            classBuilder.addField(fieldBuilder.build());
        }
    }

    public void writeClass( final String packageName, final String className, final Messager log, final Filer filer) {
        log.printMessage(Diagnostic.Kind.NOTE, "Generate contract for " + packageName + "." + className);
        try {
            JavaFile javaFile = JavaFile.builder(packageName, generatedModel).build();
            javaFile.writeTo( filer );
        } catch (IOException e) {
            log.printMessage(Diagnostic.Kind.WARNING, "File wasn't generated.");
        }
    }
}
