package de.wackernagel.android.sidekick.annotations.processor;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;

import static com.squareup.javapoet.TypeSpec.classBuilder;
import static javax.lang.model.element.Modifier.PUBLIC;

public class ModelGenerator {

    private TypeSpec generatedModel;

    private static final ClassName nullable = ClassName.get( "android.support.annotation", "Nullable" );
    private static final ClassName nonNull = ClassName.get( "android.support.annotation", "NonNull" );
    private static final ClassName objects = ClassName.get( "de.wackernagel.android.sidekick.compats", "ObjectsCompat" );
    private static final ClassName cursor = ClassName.get( "android.database", "Cursor" );

    public ModelGenerator(final TableDefinition tableDefinition, final Set<ColumnDefinition> columnDefinitions) {
        final TypeName objectCreatorInterface = ParameterizedTypeName.get(
                ClassName.get("de.wackernagel.android.sidekick.frameworks.objectcursor", "ObjectCreator"),
                ClassName.get(tableDefinition.getPackageName(), tableDefinition.getObjectType(false, true)));

        final TypeSpec.Builder classBuilder = classBuilder(tableDefinition.getObjectType(false, true))
                .addSuperinterface( objectCreatorInterface )
                .addModifiers(PUBLIC)
                .addJavadoc("Generated by Sidekick at " + new SimpleDateFormat("dd.MM.yyyy HH:mm", Locale.ENGLISH).format(new Date()) + "\n");

        memberField(classBuilder, columnDefinitions);
        privateConstructor(classBuilder, columnDefinitions);
        constructor(classBuilder, columnDefinitions);
        objectCreator(classBuilder, tableDefinition, columnDefinitions);
        getterAndSetter(classBuilder, columnDefinitions);
        toString(classBuilder, columnDefinitions, tableDefinition.getObjectType(false, true));
        equals(classBuilder, columnDefinitions, tableDefinition);
        hashCode(classBuilder, columnDefinitions);

        generatedModel = classBuilder.build();
    }

    private void objectCreator(TypeSpec.Builder classBuilder, TableDefinition tableDefinition, Set<ColumnDefinition> columnDefinitions) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder( "createFromCursor" )
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns( ClassName.get(tableDefinition.getPackageName(), tableDefinition.getObjectType(false, true)))
                .addParameter(cursor, "cursor", Modifier.FINAL);

        final  CodeBlock.Builder code = CodeBlock.builder();
        code.add( "return ");
        code.add( "new " + tableDefinition.getObjectType(false, true) + "(\n");
        int index = 0;
        for( ColumnDefinition column : columnDefinitions ) {
            if( column.isCollectionType() )
                continue;

            if( index > 0 )
                code.add( ",\n");
            code.add("\t");
            if( column.isBoolean() )
                code.add( "1 == " );
            if( column.isByte() ) {
                code.add( "(byte) " );
            }
            code.add( "cursor.get" );
            code.add( column.getCursorMethod() );
            code.add( "( " + index + " )" );
            index++;
        }
        code.add( "\n);\n");

        method.addCode( code.build() );
        classBuilder.addMethod( method.build() );
    }

    private void hashCode( final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> columns ) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("hashCode")
                .addAnnotation(Override.class)
                .returns(int.class)
                .addModifiers(Modifier.PUBLIC);

        method.addCode("return $T.hash( ", objects);
        boolean first = true;
        for( ColumnDefinition column : columns ) {
            if( !first ) {
                method.addCode( ", " );
            }
            method.addCode( "$N", column.getFieldName() + (column.isContractObjectType() ? "Id" : "") );
            first = false;
        }
        method.addCode(" );\n");

        classBuilder.addMethod( method.build() );
    }

    private static void equals( final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> columns, final TableDefinition table ) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("equals")
                .addParameter( Object.class, "obj" )
                .addAnnotation( Override.class )
                .returns(boolean.class)
                .addModifiers(Modifier.PUBLIC);

        final String modelClass = table.getObjectType(false, true);
        method.addStatement( "if( this == obj ) return true")
                .addStatement("if( obj == null || getClass() != obj.getClass() ) return false")
                .addStatement("$L other = ($L) obj", modelClass, modelClass);

        boolean first = true;
        for( ColumnDefinition column : columns ) {
            final String name = Character.toTitleCase( column.getFieldName().charAt( 0 ) ) + column.getFieldName().substring( 1 );
            final String prefix = column.isBoolean() ? "is" : "get";
            final String getter = prefix + name + (column.isContractObjectType() ? "Id" : "");
            final String member = column.getFieldName() + ( column.isContractObjectType() ? "Id" : "" );
            method.addCode((first ? "return " : "\n\t&& ") + "$T.equals( $L, other.$L() )", objects, member, getter);
            first = false;
        }
        method.addCode( ";\n" );

        classBuilder.addMethod( method.build() );
    }

    private static void toString(final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields, final String className) {
        final MethodSpec.Builder method = MethodSpec.methodBuilder("toString")
                .addAnnotation( Override.class )
                .returns( String.class )
                .addModifiers( Modifier.PUBLIC );

        final StringBuilder statement = new StringBuilder();
        final List<String> args = new ArrayList<>();

        statement.append( "return $S +" );
        args.add( className + "(" );

        int index = 0;
        for( ColumnDefinition columnDefinition : fields ) {
            statement.append("\n$S + $L +");
            args.add( (index > 0 ? ", " : "" ) + columnDefinition.getFieldName() + (columnDefinition.isContractObjectType() ? "Id" : "") + "=" );
            args.add( columnDefinition.getFieldName() + (columnDefinition.isContractObjectType() ? "Id" : "") );
            index++;
        }
        statement.append("$S");
        args.add( ")" );

        method.addStatement(statement.toString(), args.toArray());
        classBuilder.addMethod(method.build());
    }

    private static void getterAndSetter(final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields) {
        for( ColumnDefinition columnDefinition : fields ) {
            final String memberName = columnDefinition.getFieldName() + (columnDefinition.isContractObjectType() ? "Id" : "");
            final String name = Character.toTitleCase( memberName.charAt( 0 ) ) + memberName.substring( 1 );

            final String prefix = columnDefinition.isBoolean() ? "is" : "get";
            final MethodSpec.Builder getMethod = MethodSpec.methodBuilder( prefix + name)
                    .addModifiers(Modifier.PUBLIC)
                    .returns(columnDefinition.isContractObjectType() ? TypeName.INT : columnDefinition.getObjectType())
                    .addStatement("return $N", memberName );

            if( ( columnDefinition.isObjectTypeNotPrimitive() && !columnDefinition.isContractObjectType() ) || columnDefinition.isString() ) {
                if( columnDefinition.isNotNull() ) {
                    getMethod.addAnnotation(nonNull);
                } else {
                    getMethod.addAnnotation(nullable);
                }
            }

            classBuilder.addMethod(getMethod.build());

//            if( !columnDefinition.isFinal() ) {
//                final ParameterSpec.Builder param = ParameterSpec.builder(columnDefinition.getObjectType(), columnDefinition.getFieldName(), Modifier.FINAL);
//
//                if( ( columnDefinition.isObjectTypeNotPrimitive() && !columnDefinition.isContractObjectType() ) || columnDefinition.isString() ) {
//                    if( columnDefinition.isNotNull() ) {
//                        param.addAnnotation( nonNull );
//                    } else {
//                        param.addAnnotation( nullable );
//                    }
//                }
//
//                final MethodSpec.Builder setMethod = MethodSpec.methodBuilder("set" + name)
//                        .addModifiers(Modifier.PUBLIC)
//                        .returns(TypeName.VOID)
//                        .addParameter( param.build() )
//                        .addStatement("this.$N = $N", columnDefinition.getFieldName(), columnDefinition.getFieldName());
//                classBuilder.addMethod( setMethod.build() );
//            }
        }
    }

    private static void privateConstructor(final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields) {
        final MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
                .addModifiers( Modifier.PRIVATE );
        for( ColumnDefinition columnDefinition : fields ) {
            if( columnDefinition.isCollectionType() ) {
                constructor.addStatement( "this.$N = new $T()", columnDefinition.getFieldName(), columnDefinition.getInstantiableCollectionType() );
                continue;
            }

            final String memberName = columnDefinition.getFieldName() + (columnDefinition.isContractObjectType() ? "Id" : "");
            constructor.addStatement("this.$N = $L", memberName, columnDefinition.getInitValue());
        }
        classBuilder.addMethod( constructor.build() );
    }

    private static void constructor(final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields) {
        final MethodSpec.Builder constructor = MethodSpec.constructorBuilder()
                .addModifiers( Modifier.PUBLIC );
        for( ColumnDefinition columnDefinition : fields ) {
            if( columnDefinition.isCollectionType() ) {
                constructor.addStatement( "this.$N = new $T()", columnDefinition.getFieldName(), columnDefinition.getInstantiableCollectionType() );
                continue;
            }

            final String memberName = columnDefinition.getFieldName() + (columnDefinition.isContractObjectType() ? "Id" : "");
            final ParameterSpec.Builder parameter = ParameterSpec.builder(
                    columnDefinition.isContractObjectType() ? TypeName.INT : columnDefinition.getObjectType(),
                    memberName,
                    Modifier.FINAL );

            if( ( columnDefinition.isObjectTypeNotPrimitive() && !columnDefinition.isContractObjectType() ) || columnDefinition.isString() ) {
                if( columnDefinition.isNotNull() ) {
                    parameter.addAnnotation( nonNull );
                } else {
                    parameter.addAnnotation( nullable );
                }
            }

            constructor.addParameter(parameter.build())
                    .addStatement("this.$N = $N", memberName, memberName);
        }
        classBuilder.addMethod( constructor.build() );
    }

    private static void memberField( final TypeSpec.Builder classBuilder, final Set<ColumnDefinition> fields) {
        for( ColumnDefinition column : fields ) {
            final FieldSpec.Builder fieldBuilder = FieldSpec.builder(
                    column.isContractObjectType() ? TypeName.INT : column.getObjectType(),
                    column.getFieldName() + (column.isContractObjectType() ? "Id" : "" ),
                    Modifier.PRIVATE);
            if( column.isFinal() ) {
                fieldBuilder.addModifiers(Modifier.FINAL);
            }
            classBuilder.addField(fieldBuilder.build());
        }
    }

    public boolean writeClass( final String packageName, final Filer filer) {
        try {
            final JavaFile javaFile = JavaFile.builder(packageName, generatedModel).build();
            javaFile.writeTo( filer );
        } catch (IOException e) {
            return false;
        }
        return true;
    }
}
